<inject from="/component/panel" name="card"></inject>
<inject from="/component/entry" name="entry"></inject>
<inject from="/component/card-itinerary" name="card-itinerary"></inject>
<inject from="/component/edit-itinerary" name="edit-itinerary"></inject>
<inject from="/component/alert" name="alert"></inject>

<div data.load="getPackage($packageId)">
    <card title.bind="data.packageName" nofooter>
        <div slot.name="body">
            <entry type="button" value="Add Itinerary" click.trigger="onAddItinerary($packageId)" if.bind="!$editItineraryId"></entry>
        </div>
    </card>
    <alert alertType.bind="@alert.type" message.bind="@alert.text"></alert>
    <edit-itinerary if.bind="$editItineraryId == -1" save.trigger="onSaveItinerary(event, $packageId)" cancel.trigger="onCancelEdit($packageId)" defaults.bind="calculateDefaults($editItineraryId)"></edit-itinerary>
    <div data.load="queryItineraries($packageId)">
        <p for.each="itr in data">
            <card-itinerary if.bind="itr.id != $editItineraryId" itr.bind="itr" edit.trigger="onEdit(event, $packageId)" delete.trigger="onDelete(event)"></card-itinerary>
            <edit-itinerary if.bind="itr.id == $editItineraryId" itinerary.bind="itr" save.trigger="onSaveItinerary(event, $packageId)" cancel.trigger="onCancelEdit($packageId)" defaults.bind="calculateDefaults($editItineraryId)"></edit-itinerary>
        </p>
    </div>
</div>

<script>
    function initState(props) {
        return {
            itinerary: [],
            alert : {
                text: null,
                type: ""
            }
        }
    }

	function queryItineraries(packageId) {
	    var self = this;
		return new Promise(function (resolve) {
			var q = {
				"packageId": packageId,
                "$sort": {"fromDateTime":1}
            }
			dpd.itineraries.get(q, function (itr, err) {
				if(err) {
					self.state.alert.text = err;
                    self.state.alert.type="error";
                    self.itinerary=[];
					$patchChanges();
				} else {
                    self.state.alert.text = null;
                    self.state.alert.type="";
                    self.itinerary=itr;
					resolve(itr);
				}
			});
		});
	}

	function getPackage(id){
		return new Promise(function(resolve){
			dpd.packages.get(id, function(result, err){
				resolve(result);
			});
		});
	}

	function onSaveItinerary(itinerary, packageId) {
		debugger;
		itinerary = itinerary.data;
        itinerary.packageId = packageId;
        if(itinerary.id=="") {
            dpd.itineraries.post(itinerary, function(result, err) {
                debugger;
                if (err) {
                    self.state.alert.text = err;
                    self.state.alert.type="error";
                }
                if(result) {
                    self.state.alert.text = null;
                    self.state.alert.type="";
                    $patchChanges();
                    //window.location.hash="#app/action.myItinerary:packageId=" + packageId+ ":editItineraryId=-1";
                }
            });
        }
        else {
            debugger;
            dpd.itineraries.put(itinerary.id, itinerary, function(result, err) {
                debugger;
                if(err) {
                    self.state.alert.text = err;
                    self.state.alert.type="error";
                }
                else {
                    self.state.alert.text = null;
                    self.state.alert.type="";
                    window.location.hash="#app/action.myItinerary:packageId=" + packageId;
                }
            });
        }
	}

	function calculateDefaults(itineraryId) {
	    var result = {
	        date: {
                default: (new Date())
            },
            entryType:'Transport'
        };
	    debugger;
	    if(this.state && this.state.itinerary && this.state.itinerary.length > 0) {
            if (itineraryId != -1) {
                for (var i = 0; i < this.state.itinerary.length; i++) {
                    if (this.state.itinerary[i].id == itineraryId) {
                        if (i > 0) {
                            result.date.min = this.state.itinerary[i - 1].toDateTime;
                        }
                        if (i < this.state.itinerary.length - 1) {
                            result.date.max = this.state.itinerary[i + 1].fromDateTime;
                        }
                        return result;
                    }
                }
            }
            else {
                result.date.default = this.state.itinerary[this.state.itinerary.length - 1].toDateTime;
                result.entryType = this.state.itinerary[this.state.itinerary.length - 1].entry.transport ? 'Hotel' : 'Transport';
            }
        }
        return result;
    }

	function onCancelEdit(packageId) {
		window.location.hash="#app/action.myItinerary:packageId=" + packageId;
	}

	function onAddItinerary(packageId) {
		window.location.hash="#app/action.myItinerary:packageId=" + packageId + ":editItineraryId=-1";
    }
	function onEdit(itineraryId, packageId) {
	    var dateLimits = calculateDateLimits(itineraryId);
		window.location.hash="#app/action.myItinerary:packageId=" + packageId + ":editItineraryId=" + itineraryId.data;
    }

    function onDelete(itineraryId, packageId) {
		debugger;
		return new Promise(function(resolve){
			dpd.itineraries.del(itineraryId.data,function(err){
				debugger;
				if(err){
					if (err) {
                        self.state.alert.text = err;
                        self.state.alert.type="error";
					}
                }
                else {
                    self.state.alert.text = null;
                    self.state.alert.type="";
					window.location.hash="#app/action.myItinerary:packageId=" + packageId;
				}
            });
        });
    }
</script>