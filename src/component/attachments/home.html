<inject from="/component/attachments/list" name="list"></inject>
<inject from="/component/entry" name="entry"></inject>

<div data.load="loadFiles()">
    <div class="container">
        <entry naked type="label" prompt.bind="$prompt"></entry>
    </div>
    <div ref.name="existingFiles">
        <list list.bind="data" folder="upload/" delete.trigger="onDelete(event)" undelete.trigger="onUndelete(event)" readonly.bind="$readonly"></list>
    </div>
    <div ref.name="newFiles">
        <list list.bind="@newFiles" cancelAdd.trigger="onCancelAdd(event)"></list>
    </div>
    <div if.bind="!$readonly">
        <form>
            <entry type="file" name="addFile" change.trigger="onAddFile()"></entry>
        </form>
    </div>
    <div class="container">
        <div class="row">
            <entry type="label" if.bind="@error" class="custom-entry-prompt custom-error-text" prompt.bind="@error"></entry>
        </div>
    </div>
</div>
<script>
    function initState(props){
    	var self = this;
	    if(props.onSave) props.onSave.subscribe(onSaveEvent.bind(self));
	    if(props.alert) props.alert.onError.subscribe(errorSelector.bind(this));
	    //debugger;
    	return {
            newFiles:[],
            delFiles:[],
            collection: props.collection,
            userId: props.userId,
            maxSize:props.maxSize ? props.maxSize : 1000000,
            name: props.name,
		    error:null,
        }
    }

    function errorSelector(errors) {
	    this._state.error=null;
	    if(errors) {
		    for (var i in errors) {
			    if ((this._state.name && errors[i].name == this._state.name) || (this._state.alias && errors[i].name == this._state.alias)) {
				    this._state.error = errors[i].message;
				    errors.splice(i, 1);
			    }
		    }
	    }
    }

    function loadFiles() {
    	var self = this;
    	//debugger;
    	return new Promise(function(resolve){
    		//debugger;
            var q = {};
            if(self.state.userId) {
            	q.uploaderId = self.state.userId;
            }
		    dpd[self.state.collection].get(q, function(data, statusCode, headers, config) {
		    	//debugger;
		    	resolve(data);
		    });
        });
    }

    function onFileDeleted(event) {
	    $patchChanges("existingFiles");
    }

    function onDelete(event) {
	    //debugger;
	    this.state.delFiles = this.state.delFiles.concat(event.data);
    }

    function onUndelete(event) {
	    debugger;
        var i = this.state.delFiles.indexOf(event.data);
        if(i >= 0) this.state.delFiles.splice(i, 1);
    }

    function onAddFile(){
	    var form = this.target.form;
	    var self = this;
        this.state.newFiles = this.state.newFiles.concat(form.elements.addFile.files[0])
	    form.reset();
	    $patchChanges("newFiles");
	    return;
    }

    function onCancelAdd(event){
    	debugger;
	    var i = this.state.newFiles.indexOf(event.data);
	    if(i >= 0) this.state.newFiles.splice(i, 1);
	    $patchChanges("newFiles");
	    return;
    }

    function onSaveEvent(fnc) {
        console.log('preparing all promises');
	    var self = this;
	    debugger;
	    Promise.all(deleteFiles.bind(this)().concat(saveFiles.bind(this)())).then(function() {
	        debugger;
	    	fnc();
	    }).catch(function(err){
	    	fnc(err);
        });
    }

    function deleteFiles(){
	    console.log('promise to delete');
    	var self = this;
    	var promises=[];
    	for(var i in self._state.delFiles) {
    		promises.push(
                new Promise(function(resolve, reject){
                    dpd[self._state.collection].del(self._state.delFiles[i], function (res, err) {
                    	if(err) {
                    		debugger;
                    		reject({name: self._state.name, message: err});
	                    } else {
		                    console.log(res);
		                    resolve();
	                    }
                    });
                })
            );
        }
        return promises;
    }

    function saveFiles() {
	    var self = this;
	    console.log('promise to upload');
	    return [new Promise(function(resolve, reject){
		    var fd = new FormData()
            //debugger;
		    if(self._state.newFiles.length > 0) {
			    for(var i in self._state.newFiles) {
			    	if(self._state.newFiles[i].size > self._state.maxSize) {
			    		reject({name: self._state.name, message: self._state.newFiles[i].name + " (" + self._state.newFiles[i].size.toGMKByte() + ") is too large. Max size is " + self._state.maxSize.toGMKByte() + ""});
                    } else {
					    fd.append("uploadedFile", self._state.newFiles[i])
				    }
			    }
			    var xhr = new XMLHttpRequest();
			    xhr.open('PUT', '/' + self._state.collection);
			    xhr.onload = function () {
				    var response = JSON.parse(this.responseText);

				    if(this.status < 300) {
				    	console.log("Upload success.");
					    resolve();
				    } else {
					    console.log(response.message);
					    reject({name: self._state.name, message: response.message});
				    }
			    };
			    xhr.onerror = function (err) {
                    reject({name: self._state.name, message: err});
			    }
			    xhr.send(fd);
		    } else {
			    console.log("Nothing to upload.");
			    resolve();
		    }
	    })];
    }


</script>